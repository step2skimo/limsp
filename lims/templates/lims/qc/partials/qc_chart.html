<div class="mb-4">
  <label for="parameter-select" class="font-semibold">Select Parameter:</label>
  <select id="parameter-select" class="border rounded px-2 py-1"></select>
  <button id="download-btn" class="bg-green-600 text-white px-4 py-2 rounded ml-2">Download Chart</button>
</div>

<div id="qc-chart" style="height:600px;"></div>

<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script>
  let fullData = [];
  let updateInterval;

  function fetchDataAndRender(initial = false) {
    fetch("{% url 'qc_metrics_chart_data' %}")
      .then(response => response.json())
      .then(data => {
        fullData = data;
        const uniqueParams = [...new Set(data.map(q => q.parameter))];

        if (initial) {
          // populate dropdown
          const paramSelect = document.getElementById("parameter-select");
          paramSelect.innerHTML = "";
          uniqueParams.forEach(p => {
            const opt = document.createElement("option");
            opt.value = p;
            opt.text = p;
            paramSelect.add(opt);
          });

          paramSelect.addEventListener("change", e => {
            renderChart(e.target.value);
          });
        }
        const selectedParam = document.getElementById("parameter-select").value || uniqueParams[0];
        renderChart(selectedParam);
      })
      .catch(error => console.error("Fetch error:", error));
  }

  function renderChart(parameter) {
    const filtered = fullData.filter(q => q.parameter === parameter);

    // group by analyst
    const groupedByAnalyst = {};
    filtered.forEach(q => {
      const analyst = q.analyst || "Unknown";
      if (!groupedByAnalyst[analyst]) groupedByAnalyst[analyst] = [];
      groupedByAnalyst[analyst].push(q);
    });

    const traces = [];
    Object.keys(groupedByAnalyst).forEach(analyst => {
      const group = groupedByAnalyst[analyst];
      const trace = {
        x: group.map(q => q.created_at),
        y: group.map(q => q.measured_value),
        mode: 'markers+lines',
        name: `Analyst: ${analyst}`,
        marker: {
          color: group.map(q => q.status === 'pass' ? '#16a34a' : '#dc2626'),
          size: 12
        },
        text: group.map(q => `
          Sample: ${q.sample}<br>
          Status: ${q.status}<br>
          Analyst: ${q.analyst}<br>
          Measured: ${q.measured_value}
        `),
        hoverinfo: 'text+y'
      };
      traces.push(trace);
    });

    // acceptable limits
    const minLine = {
      x: filtered.map(q => q.created_at),
      y: filtered.map(q => q.min_acceptable),
      mode: 'lines',
      line: { color: '#f97316', dash: 'dot' },
      name: 'Min Acceptable'
    };
    const maxLine = {
      x: filtered.map(q => q.created_at),
      y: filtered.map(q => q.max_acceptable),
      mode: 'lines',
      line: { color: '#f97316', dash: 'dot' },
      name: 'Max Acceptable'
    };

    traces.push(minLine);
    traces.push(maxLine);

    const layout = {
      title: `QC Results for ${parameter}`,
      xaxis: { title: 'Date', type: 'date' },
      yaxis: { title: 'Measured Value' },
      hovermode: 'closest',
      legend: { orientation: 'h', x: 0, y: -0.2 },
      margin: { b: 120 }
    };

    Plotly.newPlot('qc-chart', traces, layout, {responsive: true});
  }

  document.addEventListener("DOMContentLoaded", function() {
    document.getElementById("download-btn").addEventListener("click", () => {
      Plotly.downloadImage('qc-chart', {
        format: 'png',
        height: 600,
        width: 1000,
        filename: 'qc_metrics_dashboard'
      });
    });
  });

  // start
  fetchDataAndRender(true);
  updateInterval = setInterval(() => {
    fetchDataAndRender();
  }, 10000);
</script>
